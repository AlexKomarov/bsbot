// Generated by CoffeeScript 1.10.0
(function() {
  var Adapter, CatchAllMessage, EnterMessage, LeaveMessage, Message, SlackBot, SlackClient, TextMessage, TopicMessage, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require.main.require('hubot'), Adapter = ref.Adapter, TextMessage = ref.TextMessage, EnterMessage = ref.EnterMessage, LeaveMessage = ref.LeaveMessage, TopicMessage = ref.TopicMessage, Message = ref.Message, CatchAllMessage = ref.CatchAllMessage;

  SlackClient = require('./client');

  SlackBot = (function(superClass) {
    extend(SlackBot, superClass);

    function SlackBot(robot, options) {
      this.robot = robot;
      this.options = options;
      this.message = bind(this.message, this);
      this.error = bind(this.error, this);
      this.close = bind(this.close, this);
      this.authenticated = bind(this.authenticated, this);
      this.open = bind(this.open, this);
      this.client = new SlackClient(this.options);
    }


    /*
    Slackbot initialization
     */

    SlackBot.prototype.run = function() {
      var ref1;
      if (!this.options.token) {
        return this.robot.logger.error("No service token provided to Hubot");
      }
      if (!((ref1 = this.options.token.substring(0, 5)) === 'xoxb-' || ref1 === 'xoxp-')) {
        return this.robot.logger.error("Invalid service token provided, please follow the upgrade instructions");
      }
      this.client.on('open', this.open);
      this.client.on('close', this.close);
      this.client.on('error', this.error);
      this.client.on('message', this.message);
      this.client.on('authenticated', this.authenticated);
      return this.client.connect();
    };


    /*
    Slack client has opened the connection
     */

    SlackBot.prototype.open = function() {
      this.robot.logger.info('Slack client now connected');
      return this.emit("connected");
    };


    /*
    Slack client has authenticated
     */

    SlackBot.prototype.authenticated = function(identity) {
      var team;
      this.self = identity.self, team = identity.team;
      this.robot.name = this.self.name;
      return this.robot.logger.info("Logged in as " + this.robot.name + " of " + team.name);
    };


    /*
    Slack client has closed the connection
     */

    SlackBot.prototype.close = function() {
      if (this.options.autoReconnect) {
        return this.robot.logger.info('Slack client closed, waiting for reconnect');
      } else {
        this.robot.logger.info('Slack client connection was closed, exiting hubot process');
        this.client.disconnect();
        return process.exit(1);
      }
    };


    /*
    Slack client received an error
     */

    SlackBot.prototype.error = function(error) {
      if (error.code === -1) {
        return this.robot.logger.warning("Received rate limiting error " + (JSON.stringify(error)));
      }
      return this.robot.emit('error', error);
    };


    /*
    Hubot is sending a message to Slack
     */

    SlackBot.prototype.send = function() {
      var envelope, i, len, message, messages, sent_messages;
      envelope = arguments[0], messages = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      sent_messages = [];
      for (i = 0, len = messages.length; i < len; i++) {
        message = messages[i];
        if (message !== '') {
          this.robot.logger.debug("Sending to " + envelope.room + ": " + message);
          sent_messages.push(this.client.send(envelope, message));
        }
      }
      return sent_messages;
    };


    /*
    Hubot is replying to a Slack message
     */

    SlackBot.prototype.reply = function() {
      var envelope, i, len, message, messages, sent_messages;
      envelope = arguments[0], messages = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      sent_messages = [];
      for (i = 0, len = messages.length; i < len; i++) {
        message = messages[i];
        if (message !== '') {
          if (envelope.room[0] !== 'D') {
            message = "<@" + envelope.user.id + ">: " + message;
          }
          this.robot.logger.debug("Sending to " + envelope.room + ": " + message);
          sent_messages.push(this.client.send(envelope, message));
        }
      }
      return sent_messages;
    };


    /*
    Hubot is setting the Slack channel topic
     */

    SlackBot.prototype.topic = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (envelope.room[0] === 'D') {
        return;
      }
      return this.client.setTopic(envelope.room, strings.join("\n"));
    };


    /*
    Message received from Slack
     */

    SlackBot.prototype.message = function(message) {
      var bot, channel, subtype, text, topic, user;
      text = message.text, user = message.user, channel = message.channel, subtype = message.subtype, topic = message.topic, bot = message.bot;
      subtype = subtype || 'message';
      if (bot) {
        user = bot;
      }
      if (user) {
        user = user;
      }
      if (!user && !bot) {
        user = {};
      }
      user.room = channel.id;
      if (channel.id[0] === 'D') {
        text = this.robot.name + " " + text;
        if (channel.name == null) {
          channel.name = channel._modelName;
        }
      }
      switch (subtype) {
        case 'message':
        case 'bot_message':
          this.robot.logger.debug("Received message: '" + text + "' in channel: " + channel.name + ", from: " + user.name);
          return this.receive(new TextMessage(user, text, message.ts));
        case 'channel_join':
        case 'group_join':
          this.robot.logger.debug(user.name + " has joined " + channel.name);
          return this.receive(new EnterMessage(user));
        case 'channel_leave':
        case 'group_leave':
          this.robot.logger.debug(user.name + " has left " + channel.name);
          return this.receive(new LeaveMessage(user));
        case 'channel_topic':
        case 'group_topic':
          this.robot.logger.debug(user.name + " set the topic in " + channel.name + " to " + topic);
          return this.receive(new TopicMessage(user, message.topic, message.ts));
        default:
          this.robot.logger.debug("Received message: '" + text + "' in channel: " + channel.name + ", subtype: " + subtype);
          message.user = user;
          return this.receive(new CatchAllMessage(message));
      }
    };

    return SlackBot;

  })(Adapter);

  module.exports = SlackBot;

}).call(this);

//# sourceMappingURL=bot.js.map
