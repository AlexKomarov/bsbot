// Generated by CoffeeScript 1.10.0
(function() {
  var MemoryDataStore, RtmClient, SLACK_CLIENT_OPTIONS, SlackClient, SlackFormatter, WebClient, _, ref;

  ref = require('@slack/client'), RtmClient = ref.RtmClient, WebClient = ref.WebClient, MemoryDataStore = ref.MemoryDataStore;

  SlackFormatter = require('./formatter');

  _ = require('lodash');

  SLACK_CLIENT_OPTIONS = {
    dataStore: new MemoryDataStore()
  };

  SlackClient = (function() {
    function SlackClient(options) {
      _.merge(SLACK_CLIENT_OPTIONS, options);
      this.rtm = new RtmClient(options.token, options);
      this.web = new WebClient(options.token, options);
      this.format = new SlackFormatter(this.rtm.dataStore);
      this.listeners = [];
    }


    /*
    Open connection to the Slack RTM API
     */

    SlackClient.prototype.connect = function() {
      return this.rtm.login();
    };


    /*
    Slack RTM event delegates
     */

    SlackClient.prototype.on = function(name, callback) {
      this.listeners.push(name);
      if (name === "message") {
        return this.rtm.on(name, (function(_this) {
          return function(message) {
            var bot_id, channel, user;
            user = message.user, channel = message.channel, bot_id = message.bot_id;
            message.text = _this.format.incoming(message);
            if (user) {
              message.user = _this.rtm.dataStore.getUserById(user);
            }
            if (bot_id) {
              message.bot = _this.rtm.dataStore.getBotById(bot_id);
            }
            if (channel) {
              message.channel = _this.rtm.dataStore.getChannelGroupOrDMById(channel);
            }
            return callback(message);
          };
        })(this));
      } else {
        return this.rtm.on(name, callback);
      }
    };


    /*
    Disconnect from the Slack RTM API and remove all listeners
     */

    SlackClient.prototype.disconnect = function() {
      var i, len, name, ref1;
      ref1 = this.listeners;
      for (i = 0, len = ref1.length; i < len; i++) {
        name = ref1[i];
        this.rtm.removeListener(name);
      }
      return this.listeners = [];
    };


    /*
    Set a channel's topic
     */

    SlackClient.prototype.setTopic = function(id, topic) {
      return this.web.channels.setTopic(id, topic);
    };


    /*
    Send a message to Slack using the best client for the message type
     */

    SlackClient.prototype.send = function(envelope, message) {
      message = this.format.outgoing(message);
      if (typeof message !== 'string') {
        return this.web.chat.postMessage(envelope.room, message.text, message);
      } else if (/<.+\|.+>/.test(message)) {
        return this.web.chat.postMessage(envelope.room, message);
      } else {
        return this.rtm.sendMessage(message, envelope.room);
      }
    };

    return SlackClient;

  })();

  module.exports = SlackClient;

}).call(this);

//# sourceMappingURL=client.js.map
