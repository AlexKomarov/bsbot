// Generated by CoffeeScript 1.10.0
(function() {
  var MESSAGE_RESERVED_KEYWORDS, SlackFormatter,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MESSAGE_RESERVED_KEYWORDS = ['channel', 'group', 'everyone', 'here'];

  SlackFormatter = (function() {
    function SlackFormatter(dataStore) {
      this.dataStore = dataStore;
    }


    /*
    Formats links and ids
     */

    SlackFormatter.prototype.links = function(text) {
      var regex;
      regex = /<([@#!])?([^>|]+)(?:\|([^>]+))?>/g;
      text = text.replace(regex, (function(_this) {
        return function(m, type, link, label) {
          var channel, user;
          switch (type) {
            case '@':
              if (label) {
                return label;
              }
              user = _this.dataStore.getUserById(link);
              if (user) {
                return "@" + user.name;
              }
              break;
            case '#':
              if (label) {
                return label;
              }
              channel = _this.dataStore.getChannelById(link);
              if (channel) {
                return "\#" + channel.name;
              }
              break;
            case '!':
              if (indexOf.call(MESSAGE_RESERVED_KEYWORDS, link) >= 0) {
                return "@" + link;
              }
              break;
            default:
              link = link.replace(/^mailto:/, '');
              if (label && -1 === link.indexOf(label)) {
                return label + " (" + link + ")";
              } else {
                return link;
              }
          }
        };
      })(this));
      text = text.replace(/&lt;/g, '<');
      text = text.replace(/&gt;/g, '>');
      return text = text.replace(/&amp;/g, '&');
    };


    /*
    Flattens message text and attachments into a multi-line string
     */

    SlackFormatter.prototype.flatten = function(message) {
      var attachment, i, len, ref, text;
      text = [];
      if (message.text) {
        text.push(message.text);
      }
      ref = message.attachments || [];
      for (i = 0, len = ref.length; i < len; i++) {
        attachment = ref[i];
        text.push(attachment.fallback);
      }
      return text.join('\n');
    };


    /* 
    Recursively replace @username with <@UXXXXX> for mentioning users and channels
     */

    SlackFormatter.prototype.mentions = function(text) {
      var key, value;
      if (text === null) {
        return;
      }
      if (typeof text === 'string') {
        return text.replace(/(?:^| )@([\w]+)/gm, (function(_this) {
          return function(match, username) {
            var user;
            user = _this.dataStore.getUserByName(username);
            if (user) {
              return match = match.replace(/@[\w]+/, "<@" + user.id + ">");
            } else if (indexOf.call(MESSAGE_RESERVED_KEYWORDS, username) >= 0) {
              return match = match.replace(/@[\w]+/, "<!" + username + ">");
            } else {
              return match;
            }
          };
        })(this));
      } else if (typeof text === 'object') {
        for (key in text) {
          value = text[key];
          text[key] = this.mentions(value);
        }
        return text;
      }
    };


    /*
    Formats an incoming Slack message
     */

    SlackFormatter.prototype.incoming = function(message) {
      return this.links(this.flatten(message));
    };


    /*
    Formats outgoing messages
     */

    SlackFormatter.prototype.outgoing = function(message) {
      return this.mentions(message);
    };

    return SlackFormatter;

  })();

  module.exports = SlackFormatter;

}).call(this);

//# sourceMappingURL=formatter.js.map
